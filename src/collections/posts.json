{
  "categories": [
    {
      "category": "random",
      "data": [
        {
          "filename": "set-up-posts-selectbar.md",
          "frontmatter": {
            "layout": "../../../layouts/post-layout.astro",
            "title": "Got almost everything set up!",
            "description": "engineering log",
            "dateFormatted": "May 16th, 2024",
            "link": "/posts/random/set-up-posts-selectbar",
            "category": "random"
          },
          "content": "\n## üìù **Here's what I did**\n\nJust got posts categorization set up with React üéâ:<br />\n-- integrate Astro with React<br />\n-- make responsive select bar in React file<br />\n-- make routing works<br />\n\nI want to make i18n works too, but probably later...\n"
        }
      ]
    },
    {
      "category": "react",
      "data": [
        {
          "filename": "proxy-state-valtio.md",
          "frontmatter": {
            "layout": "../../../layouts/post-layout.astro",
            "title": "proxy state valtio",
            "description": "the implementation of proxy state",
            "dateFormatted": "May 31st, 2024",
            "link": "/posts/react/proxy-state-valtio",
            "category": "react"
          },
          "content": "\n## Valtio Example\n\nValtio can do something like:\n\n```javascript\nimport { proxy, useSnapshot } from \"valtio\";\n\nconst state = proxy({ count: 0, text: \"hello\" });\n\n// This will re-render on `state.count` change\n// but not on `state.text` change\nfunction Counter() {\n  const snap = useSnapshot(state);\n  return (\n    <div>\n      {snap.count}\n      <button onClick={() => ++state.count}>+1</button>\n    </div>\n  );\n}\n\n// you can mutate the state from anywhere\nsetInterval(() => {\n  ++state.count;\n}, 1000);\n```\n\n## Basic Implementation\n\n```javascript\nimport React from 'react'\n\nexport function proxy<T extends object>(initialValue: T): T {\n\n  // keep track of the keys of the object that are being used in the component\n  let rendered = new Set<keyof T>()\n  // this force update function would update the component where state is used\n  // need to make this an array if there're multiple components using proxy state\n  let forceUpdateFn: (()=>void)\n\n  return new Proxy(initialValue,{\n    get(target, prop) {\n      // whenever state is being used in a component, this function would be called\n      // and we add the used key to the rendered set\n      // so that we know whether we need to update components\n      rendered.add(prop as keyof T)\n      return Reflect.get(target, prop);\n    },\n    set(target, prop, value){\n      // if prop is 'forceUpdate', we assign the prop to forceUpdateFn\n      if(prop === 'forceUpdate'){\n        forceUpdateFn = value\n        return false\n      }\n      // no change do not update\n      if(Reflect.get(target, prop) === value){\n        return true\n      }\n      // update state\n      const result = Reflect.set(target, prop, value);\n      // re-render components where state is used\n      if(result && rendered.has(prop as keyof T) && forceUpdateFn){\n        // recalculate rendered\n        rendered.clear();\n        forceUpdateFn()\n      }\n      return result\n    }\n  })\n}\n```\n\n\\*This proxy component is just a simple implementation, it only considers the scenario where only one state exists, so when you have more than one state, this proxy component would update all components that use any state.\n\n```javascript\nexport function useSnapshot<T extends object>(proxy: T): T {\n  const [_, updateFunc] = React.useState(0)\n  // setting forceUpdateFn in proxy\n  Reflect.set(proxy, 'forceUpdate', ()=>updateFunc((prev)=>prev+1))\n  return proxy\n}\n```\n\nWhenever `useSnapshot` is called in a component, an `updateFunc` would be stored in the proxy component. In this way, when a state value is updated, we can update all components where the state is called inside the proxy component.\n\n## The Usage\n\n```javascript\nconst state = proxy({ count: 100, text: \"hello\", mode: \"count\" });\n\nexport function App() {\n  const snap = useSnapshot(state);\n  return <div>{snap.mode === \"count\" ? snap.count : snap.text}</div>;\n}\n```\n"
        },
        {
          "filename": "radix-toast-stack.md",
          "frontmatter": {
            "layout": "../../../layouts/post-layout.astro",
            "title": "Radix Toast Stack",
            "description": "use radix and tailwind to build a toast stack UI",
            "dateFormatted": "June 3rd, 2024",
            "link": "/posts/react/radix-toast-stack",
            "category": "react"
          },
          "content": "\n## üìù Inspiration\n\nSaw [radix toast stack codesandbox](https://codesandbox.io/p/sandbox/radix-toast-stack-dpfx5f?file=%2Fsrc%2FToast.jsx) on codesandbox.io\n\nThe biggest advantage of this toast stack, besides the beautiful UI, is that only one state is ever needed to store all toasts.\n\nThe idea is to use a Map object to store all toasts, and we render them all at once. We shuffle, remove, sort, and style them by passing ref to each toast element.\n\n## üìù Problems\n\nIn Radix toast, there's inner state and custom state. Things like `ToastPrimitive.Action`, `ToastPrimitive.Close`, and `duration`, they tell `onOpenChange` that state is updated. Therefore, in the original Codesandbox, when inner state is updated, we can accordingly update our custom state by calling:\n\n```javascript\nonOpenChange={(open) => {\n    if (!open) {\n        toastElementsMapRef.current.delete(key);\n        sortToasts();\n        if (!open) {\n            setTimeout(() => {\n                handleRemoveToast(key);\n            }, ANIMATION_OUT_DURATION);\n        }\n    }\n}}\n```\n\nHowever, in this Codesandbox, toast state is not controlled, meaning the open state of each toast is not passed in the radix `<ToastPrimitive.Root />`, which means we can't know for sure the current state of any toast.\n\nAnother drawback of this Codesandbox is that it uses React Context to pass down state and toasts' refs, which means its context provider needs to wrap around the entire app, which means it would cause unnecessary rerenders for some components.\n\n## üìù Solution\n\nTo fix this, I use Zustand and passing open state to `<ToastPrimitive.Root />`, here's the implementation of the toast provider:\n\n```javascript\nexport const ANIMATION_OUT_DURATION = 350;\n\nexport interface ToastProviderProps extends React.ComponentProps<typeof ToastPrimitive.Provider> {\n  children?: React.ReactNode;\n}\n\nexport const ToastProvider2 = ({ children, ...props }: ToastProviderProps) => {\n  // toasts store\n  const toastsMap = useStore(state => state.toastsMap);\n  const removeToast = useStore(state => state.removeToast);\n  const setToastOpenState = useStore(state => state.setToastOpenState);\n\n  // use ref to store toast dom elements\n  const toastElementsMapRef = React.useRef(new Map());\n  // use ref to store viewport dom element\n  const viewportRef = React.useRef<HTMLOListElement | null>(null);\n\n  const sortToasts = React.useCallback(() => {\n    const toastElements = Array.from(toastElementsMapRef.current).reverse();\n    const heights: number[] = [];\n\n    // add attributes to each toast element\n    toastElements.forEach(([, toast], index) => {\n      if (!toast) return;\n      const height = toast.clientHeight;\n      heights.push(height);\n      const frontToastHeight = heights[0];\n\n      // determine if the toast is the front toast or hidden\n      toast.setAttribute('data-front', index === 0);\n      toast.setAttribute('data-hidden', index > 2);\n      // set custom css properties\n      toast.style.setProperty('--index', index);\n      toast.style.setProperty('--height', `${height}px`);\n      toast.style.setProperty('--front-height', `${frontToastHeight}px`);\n      // set hover offset, so we can animate it afterwards\n      const hoverOffsetY = heights.slice(0, index).reduce((res, next) => (res += next), 0);\n      toast.style.setProperty('--hover-offset-y', `-${hoverOffsetY}px`);\n    });\n  }, []);\n\n  React.useEffect(() => {\n    const viewport = viewportRef.current;\n\n    if (viewport) {\n      // setting data-hovering attribute when the viewport is hovered/unhovered\n      const handleFocus = () => {\n        toastElementsMapRef.current.forEach(toast => {\n          toast.setAttribute('data-hovering', 'true');\n        });\n      };\n\n      const handleBlur: (ev: PointerEvent | FocusEvent) => void = event => {\n        if (!viewport.contains(event.target as Node) || viewport === event.target) {\n          toastElementsMapRef.current.forEach(toast => {\n            toast.setAttribute('data-hovering', 'false');\n          });\n        }\n      };\n\n      viewport.addEventListener('pointermove', handleFocus);\n      viewport.addEventListener('pointerleave', handleBlur);\n      viewport.addEventListener('focusin', handleFocus);\n      viewport.addEventListener('focusout', handleBlur);\n      return () => {\n        viewport.removeEventListener('pointermove', handleFocus);\n        viewport.removeEventListener('pointerleave', handleBlur);\n        viewport.removeEventListener('focusin', handleFocus);\n        viewport.removeEventListener('focusout', handleBlur);\n      };\n    }\n  }, []);\n\n  // this function will only be called when toast's inner state changes\n  // e.g. when ToastPrimitive.Close or ToastPrimitive.Action is triggered\n  const onOpenChange = React.useCallback(\n    (open: boolean, key: string) => {\n      if (!open) {\n        setToastOpenState(key, false);\n        toastElementsMapRef.current.delete(key);\n        sortToasts();\n\n        setTimeout(() => {\n          removeToast(key);\n        }, ANIMATION_OUT_DURATION);\n      }\n    },\n    [removeToast, setToastOpenState, sortToasts],\n  );\n\n  return (\n    <ToastPrimitive.Provider {...props}>\n      {children}\n      {Array.from(toastsMap).map(([key, toast]) => (\n        <Toast2\n          key={key}\n          id={key}\n          {...toast}\n          onSortToasts={sortToasts}\n          toastElementsMapRef={toastElementsMapRef}\n          onOpenChange={open => onOpenChange(open, key)}\n        />\n      ))}\n      <ToastPrimitive.Viewport\n        ref={viewportRef}\n        className={cn(\n          'fixed bottom-8 left-8 transition-transform [--stack-gap:10px]',\n          'z-[--toast-viewport-zindex] duration-[400ms] ease-[ease]',\n        )}\n      />\n    </ToastPrimitive.Provider>\n  );\n};\n\n```\n\nThe implementation of each toast:\n\n```javascript\nexport interface ToastProps extends ToastInfo {\n  onSortToasts: () => void;\n  toastElementsMapRef: React.MutableRefObject<Map<string, HTMLElement>>;\n  id: string;\n}\n\nconst Toast2 = ({\n  hasIcon = false,\n  theme = \"success\",\n  text,\n  isClosable = false,\n  onSortToasts,\n  toastElementsMapRef,\n  children,\n  actionChildren,\n  id,\n  onOpenChange,\n  open,\n  ...restProps\n}: ToastProps) => {\n  const ref = (React.useRef < HTMLLIElement) | (null > null);\n  const toastElementsMap = toastElementsMapRef?.current;\n\n  // remove toast store\n  const removeToast = useStore((state) => state.removeToast);\n\n  React.useLayoutEffect(() => {\n    if (ref.current && toastElementsMap) {\n      toastElementsMap.set(id, ref.current);\n      onSortToasts();\n    }\n  }, [id, onSortToasts, toastElementsMap]);\n\n  // when outer state change, though the changed state is passed in radix Toast through the open prop,\n  // it won't call onOpenChange, so we need to use this effect to manually remove toasts\n  React.useEffect(() => {\n    if (!open && toastElementsMap) {\n      toastElementsMap.delete(id);\n      onSortToasts();\n\n      setTimeout(() => {\n        removeToast(id);\n      }, ANIMATION_OUT_DURATION);\n    }\n  }, [id, onSortToasts, open, removeToast, toastElementsMap]);\n\n  return (\n    <ToastPrimitive.Root\n      {...restProps}\n      ref={ref}\n      // now toast is controlledby the store\n      open={open}\n      onOpenChange={onOpenChange}\n      duration={restProps.duration || 10000}\n      className={cn(\n        \"[--opacity:0]\",\n        \"[--x:--radix-toast-swipe-move-x,0]\",\n        \"[--y:calc(1px-(var(--stack-gap)*var(--index)))]\",\n        \"[--scale:calc(1-0.05*var(--index))]\",\n        \"absolute bottom-[15px] left-[15px] right-[15px] flex min-w-[276px] items-center rounded-md bg-gray-900 px-3 py-2.5 text-gray-100 shadow-xl\",\n        \"translate-z-0 translate-x-[--x] translate-y-[85px] opacity-[--opacity]\",\n        \"data-[hidden=false]:[--opacity:1] data-[hidden=true]:[--opacity:0]\",\n        'after:absolute after:left-0 after:right-0 after:top-[100%] after:h-[500px] after:w-[100%] after:bg-transparent after:content-[\"\"]',\n        \"duration-[400ms] ease-[ease]\",\n        \"data-[front=true]:translate-z-0 data-[front=true]:translate-x-[--x] data-[front=true]:translate-y-[--y,0]\",\n        \"data-[front=false]:translate-z-0 data-[front=false]:translate-x-[--x] data-[front=false]:translate-y-[--y,0] data-[front=false]:scale-[--scale]\",\n        \"data-[hovering=true]:duration-[350ms] data-[hovering=true]:[--scale:1] data-[hovering=true]:[--y:calc(var(--hover-offset-y)-var(--stack-gap)*var(--index))]\",\n        \"data-[swipe=move]:duration-[0ms]\",\n        \"data-[swipe=cancel]:[--x:0]\",\n        \"data-[state=closed]:animate-slideDown\",\n        \"data-[swipe-direction=right][data-swipe=end]:animate-slideRight\"\n      )}\n    >\n      <div className=\"mr-4 flex flex-1 gap-3\">\n        {/* leading icon */}\n        {hasIcon && theme === \"success\" && (\n          <FeaturedIconSquare color=\"teal\" theme=\"dark\">\n            <CheckSVG />\n          </FeaturedIconSquare>\n        )}\n        {hasIcon && theme === \"error\" && (\n          <FeaturedIconSquare color=\"red\" theme=\"dark\">\n            <CloseXsSVG />\n          </FeaturedIconSquare>\n        )}\n        {/* text */}\n        <ToastPrimitive.Description>{text}</ToastPrimitive.Description>\n      </div>\n\n      {/* children */}\n      {children && <>{children}</>}\n\n      {/* action button */}\n      {actionChildren && (\n        <ToastPrimitive.Action altText=\"action\" asChild>\n          {children}\n        </ToastPrimitive.Action>\n      )}\n\n      {/* close button */}\n      {isClosable && (\n        <ToastPrimitive.Close aria-label=\"Close\">\n          <CloseSmSVG />\n        </ToastPrimitive.Close>\n      )}\n    </ToastPrimitive.Root>\n  );\n};\n\nexport { Toast2 };\n```\n\nToast store:\n\n```javascript\nexport interface ToastInfo\n  extends React.ComponentProps<typeof ToastPrimitive.Root> {\n  hasIcon?: boolean;\n  theme?: \"success\" | \"error\";\n  text: string;\n  isClosable?: boolean;\n  actionChildren?: React.ReactNode;\n  children?: React.ReactNode;\n}\n\ntype ToastsSlice = {\n  toastsMap: Map<string, ToastInfo>,\n  addToast: (toastKey: string, toast: ToastInfo) => void,\n  setToastOpenState: (key: string, open: boolean) => void,\n  removeToast: (key: string) => void,\n  resetToastsMapState: () => void,\n};\n\nconst initialState = {\n  toastsMap: new Map(),\n};\n\nconst createToastsSlice: StateCreator<ToastsSlice, [], [], ToastsSlice> = (\n  set\n) => {\n  return {\n    ..._cloneDeep(initialState),\n    addToast: (toastKey: string, toast: ToastInfo) => {\n      set(\n        produce((state: ToastsSlice) => {\n          state.toastsMap.set(toastKey, { ...toast, open: true });\n        })\n      );\n    },\n    setToastOpenState: (key: string, open: boolean) => {\n      set(\n        produce((state: ToastsSlice) => {\n          const toast = state.toastsMap.get(key);\n          if (toast) {\n            state.toastsMap.set(key, { ...toast, open });\n          }\n        })\n      );\n    },\n    removeToast: (key: string) => {\n      set(\n        produce((state: ToastsSlice) => {\n          state.toastsMap.delete(key);\n        })\n      );\n    },\n    resetToastsMapState: () => set(initialState),\n  };\n};\n```\n\nNow in the new version, each toast's state is controlled by the custom state.\nIn the toast zustand store, we store the `toastsMap`, `addToast` func, `setToastOpenState` func, and `removeToast` func where `addToast`and `setToastOpenState` are used when we need to update toast in other components, and `removeToast` is used when we sync customed state with inner state of radix toast.\n\nNote that when our customed state changes, though the changed state is passed in radix Toast through the open prop, it won't call onOpenChange so we use a `useEffect` to sync states.\n\n\\*We use Tailwind in the new version.\n"
        }
      ]
    }
  ]
}